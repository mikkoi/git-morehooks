## no critic (Documentation::PodSpelling)
## no critic (Documentation::RequirePodAtEnd)
## no critic (Documentation::RequirePodSections)
## no critic (ValuesAndExpressions::RequireInterpolationOfMetachars)
## no critic (Subroutines::RequireArgUnpacking)

package Git::MoreHooks::CheckPerl;

use strict;
use warnings;
use 5.016000;
use utf8;

# ABSTRACT: Check committed files for Perl::Critic correctness.

# VERSION: generated by DZP::OurPkgVersion

=encoding utf8

=head1 STATUS

Package Git::MoreHooks is currently being developed so changes in the existing hooks are possible.


=head1 SYNOPSIS

Use package via
L<Git::Hooks|Git::Hooks>
interface (git config file).

=for Pod::Coverage check_commit_at_client check_commit_at_server

=for Pod::Coverage check_ref


=head1 DESCRIPTION

This plugin allows user to check committed Perl files 
with different static analysis tool for Perl source code.
Currently supported is only L<Perl::Critic>.
Future support is planned for L<B::Lint> and running
syntax check command F<perl -c>.

There are other ways to run Perl::Critic, such as simply running
the executable F<perlcritic>. This hook runs Perl::Critic within
the same Git::Hooks process and therefore uses the same Perl
installation and its modules. It saves you from starting a new
process for every file you check, and you can install the policies
together with everything else Git::Hooks needs.

In the case of server side repo,
this hook takes content of the new or modified files directly
from Git and passes them to Perl::Critic without writing them
to a temporary dir only for F<perlcritic> to read them again.


=head1 USAGE

To enable CheckPerl plugin, you need
to add it to the githooks.plugin configuration option:

    git config --add githooks.plugin Git::MoreHooks::CheckPerl

This plugin hooks itself to the hooks below:

=over

=for comment
The following hooks are associated to Hook Driver GITHOOKS_CHECK_PRE_COMMIT.

=item * B<pre-commit>

This hook is invoked during the commit.

=item * B<pre-applypatch>

This hook is invoked during the email-based workflow after a patch
is applied but before a commit is made.


=for :comment
The following hooks are associated to Hook Driver GITHOOKS_CHECK_AFFECTED_REFS.

=item * B<commit-received>

This hook is invoked when a commit is received by Gerrit either
by direct push or by push for review (to refs/for/branch). It
allows a push to be rejected before a review is created, or before
the branch is updated in case of a direct push.
It is called once for each commit in the push.

=item * B<pre-receive>

This hook is invoked once in the remote repository during C<git push>.

=item * B<ref-update>

This hook is invoked when a push request is received by Gerrit Code
Review.

=item * B<submit>

This is called when a user attempts to submit a change in Gerrit.
It allows the submit to be rejected.

=item * B<update>

This hook is invoked multiple times in the remote repository during
C<git push>, once per branch being updated.

=back


=head1 CONFIGURATION

This plugin is configured by the following git options.

=head3 githooks.checkperl.use-temp-files BOOL

Whenever a checker supports it, files are not written
to a temporary folder for checking. Instead they are extracted
from Git and fed directly as scalar variables to a checker
tool. If you want the checker to read a file instead,
set this config item to "1". Default is "0".

=head3 githooks.checkperl.name PATTERN

Use regexp or glob values to specify file patterns.
This item uses same pattern as L<Git::Hooks::CheckFile>
config item F<name>, but without the command.

Only the file's basename is matched against PATTERN.
(Paths are not supported.)
You can set name one or more times.

PATTERN is usually expressed with
L<globbing|https://metacpan.org/pod/File::Glob> to match files based on
their extensions, for example:

    [githooks "checkperl"]
        name = *.pl

If you need more power than globs can provide you can match using L<regular
expressions|http://perldoc.perl.org/perlre.html>, using the C<qr//>
operator, for example:

    [githooks "checkperl"]
        name = qr/xpto-\\d+.pl/

Default values are:

    [githooks "checkperl"]
        name = *.p[lm]
        name = *.psgi
        name = *.t

=head3 githooks.checkperl.critic.active BOOL

Activate or deactivate Perl::Critic check.
Set this to false ("0") if you only want to use the other
checkers.
Default is true ("1").

=head3 githooks.checkperl.critic.profile REF_AND_FILENAME

If you have committed a Perl::Critic configuration file (profile)
to the repo, you can specify here where it is.
There is no default value.
The value must have the following pattern: "ref name:file name".
E.g.

    [githooks "checkperl.critic"]
        profile = refs/heads/master:.perlcriticrc

It is not possible for this hook to simply use the current
F<.perlcriticrc> file in the repo and the currently active branch
for security reasons.

If this item is not set, Perl::Critic is started with its own
default values. It will not read the currently
present F<.perlcriticrc> file even if available.

You can alternatively set the following values
in the configuration but if B<profile> is set, they are ignored.

Please consult to
L<Perl::Critic|https://metacpan.org/pod/Perl::Critic#CONSTRUCTOR>
for further information.

=head3 githooks.checkperl.critic.severity INT / STRING

=head3 githooks.checkperl.critic.theme STRING

=head3 githooks.checkperl.critic.include LIST

=head3 githooks.checkperl.critic.exclude LIST

=head3 githooks.checkperl.critic.top INT

=head3 githooks.checkperl.critic.only BOOL

=head3 githooks.checkperl.critic.force BOOL

=head3 githooks.checkperl.critic.verbose INT

=head3 githooks.checkperl.critic.allow-unsafe BOOL


=head1 EXPORTS

This module exports the following routines that can be used directly
without using all of Git::Hooks infrastructure.

=head2 check_commit GIT

This is the routine used to implement the C<pre-commit> hook. It needs
a C<Git::More> object.

=head2 check_affected_refs GIT, REF

This is the routing used to implement the C<update> and the
C<pre-receive> hooks. It needs a C<Git::More> object and the name
of the reference affected by the current push command.

=head2 check_patchset GIT, HASH

This is the routine used to implement the C<patchset-created> Gerrit
hook. It needs a C<Git::More> object and the hash containing the
arguments passed to the hook by Gerrit.


=head1 SEE ALSO

=over

=item L<Git::Hooks|Git::Hooks>

=item L<Perl::Critic|Perl::Critic>

=item Alternative way to use Perl::Critic with Git::Hooks package: L<Git::Hooks::CheckFile|Git::Hooks::CheckFile/"CONFIGURATION">.


=head1 NOTES

Thanks go to Gustavo Leite de Mendon√ßa Chaves for his
L<Git::Hooks|https://metacpan.org/pod/Git::Hooks> package.

=cut

# use Git::MoreHooks::CheckCommitBase \&do_hook;

use Git::Hooks 2.008000;
use Path::Tiny;
use Log::Any qw{$log};
# use Params::Validate qw(:all);
use Module::Load qw{ load };
use Text::Glob qw{ glob_to_regex };
use List::MoreUtils qw( any );


my $PKG = __PACKAGE__;
my ($HOOK) = __PACKAGE__ =~ /::([^:]+)$/msx;
my $CFG = 'githooks.' . $HOOK;

=head1 SUBROUTINES/METHODS

=for Pod::Coverage check_new_or_modified_files

=cut

####################
# Hook configuration, check it and set defaults.

sub _setup_config {
    my ($git) = @_;
    $log->debugf( __PACKAGE__ . '::_setup_config(%s):', '$git' );

    my $config = $git->get_config();
    $log->tracef( __PACKAGE__ . '::_setup_config(): Current Git config:\n%s.', $config );

    # Put empty hash if there is no config items.
    $config->{ lc $CFG } //= {};

    # Set default config values.
    my $default = $config->{ lc $CFG };
    $default->{'use-temp-files'} //= [0];
    $default->{'name'} //= ['*.p[lm]', '*.psgi', '*.t'];

    $default->{'critic'} //= {};
    $default->{'b-lint'} //= {};
    $default->{'perl-c'} //= {};

    # Perl::Critic
    $default->{'critic'}->{'active'} //= [1];
    $default->{'critic'}->{'profile'} //= [];

    # B::Lint
    $default->{'b-lint'}->{'active'} //= [1];

    # Perl -c
    $default->{'perl-c'}->{'active'} //= [0];

    # Check validity of config items.
    foreach my $file_def ( @{$default->{'file'}} ) {
        $log->debugf( __PACKAGE__ . q{::} . '_setup_config(): Check for validity, config item: \'%s\'.', $file_def );
        if (
            ## no critic (RegularExpressions::ProhibitComplexRegexes)
            $file_def !~ m{^
            (?:[[:graph:]]+)
            (?:
                (?:[[:space:]]{1,}indent-size:[[:digit:]]+){1,}
                | (?:[[:space:]]{1,}indent-char:(?:space|tab|both))
            ){1,}
            (?:[[:space:]]{0,})
            $}msx
            ## use critic (RegularExpressions::ProhibitComplexRegexes)
          )
        {
            $git->error( $PKG, 'Faulty config item: \'' . $file_def . '\'.' );
            return 0;
        }
    }
    foreach my $exc_def ( @{$default->{'exception'}} ) {
        $log->debugf( __PACKAGE__ . q{::} . '_setup_config(): Check for validity, config item: \'%s\'.', $exc_def );
        if (
            ## no critic (RegularExpressions::ProhibitComplexRegexes)
            $exc_def !~ m{^
            (?:[[:space:]]{0,})   (?# Free spacing before)
            (?:[[:graph:]]+)      (?# File name pattern)
            (?:[[:space:]]{1,})   (?# Required spacing)
            (?:[[:graph:]]+)      (?# Regular expression)
            (?:[[:space:]]{0,})   (?# Free spacing after)
            $}msx
            ## use critic (RegularExpressions::ProhibitComplexRegexes)
          )
        {
            $git->error( $PKG, 'Faulty config item: \'' . $exc_def . '\'.' );
            return 0;
        }
    }
    return 1;
}

####################
# Internal

use Config::Tiny;
use Const::Fast;
const my $PERL_CRITIC_RC => '.perlcriticrc';
const my $DEFAULT_CRITIC_SEVERITY => 5;

sub _get_critic_profile {
    my ($git, $profile) = @_;
    $profile = $profile//$PERL_CRITIC_RC;
    $log->debugf( __PACKAGE__ . q{::} . '_get_critic_profile():profile=%s', $profile);

    # my $file = $git->run(qw/ls-files -s/, $profile);
    # my ($mode, $sha, $n, $filename) = split q{ }, $file;
    # $log->debugf( __PACKAGE__ . q{::}
    #     . '_get_critic_profile():(mode, sha, n, name)=(%s, %s, %s, %s)',
    #     ($mode, $sha, $n, $filename)
    # );
    my $content = $git->run(qw/cat-file -p/, $profile);
    $log->tracef( __PACKAGE__ . q{::} . '_get_critic_profile():content=%s', $content);

    return $content;
}

sub _read_critic_profile {
    my ($git, $content) = @_;
    my $c = Config::Tiny->read_string( $content );
    return $c;
}

sub _set_critic {
    my ($git) = @_;
    my $cfg_section = $CFG . q{.} . 'critic';
    my $pc_rc_filename = $git->get_config( $cfg_section => 'profile');
    $log->tracef( __PACKAGE__ . q{::} . '_set_critic():pc_rc_filename=%s', $pc_rc_filename);

    load 'Perl::Critic';
    load 'Perl::Critic::Violation';
    load 'Perl::Critic::Utils';

    # my $pc = Perl::Critic->new( -severity => 0, -verbose => 1, '-profile' => $pc_rc_filename//q{});
    my $content = _get_critic_profile( $git, $pc_rc_filename );
    my $rc = _read_critic_profile( $git, $content );
    $log->debugf( __PACKAGE__ . q{::}
        . '_set_critic():(rc)=(%s)', $rc
    );

    my %cfg;
    $cfg{'-profile'} = q{};  # Do not read a .perlcriticrc file!
    ## no critic (ControlStructures::ProhibitPostfixControls)
    my $r = $rc->{_};
    $cfg{'-severity'} = exists $r->{'severity'} ? $r->{'severity'} : $DEFAULT_CRITIC_SEVERITY;
    $cfg{'-theme'} = $r->{'theme'} if(exists $r->{'theme'});
    $cfg{'-include'} = [ split qr/\s+/msx, $r->{'include'} ] if exists $r->{'include'};
    $cfg{'-exclude'} = [ split qr/\s+/msx, $r->{'exclude'} ] if exists $r->{'exclude'};
    $cfg{'-top'} = $r->{'top'} if exists $r->{'top'};
    $cfg{'-only'} = $r->{'only'} if exists $r->{'only'};
    $cfg{'-force'} = $r->{'force'} if exists $r->{'force'};
    $cfg{'-verbose'} = $r->{'verbose'} if exists $r->{'verbose'};
    $cfg{'-allow-unsafe'} = $r->{'allow-unsafe'} if exists $r->{'allow-unsafe'};
    $log->debugf( __PACKAGE__ . q{::} . '_set_critic():(cfg)=(%s)', \%cfg);

    my $pc = Perl::Critic->new( %cfg );
    $log->debugf( __PACKAGE__ . q{::} . '_set_critic():(Perl::Critic config)=(%s)', $pc->config);

    # set the format to be a comment
    my $verbosity = $pc->config->verbose;
    my $format = Perl::Critic::Utils::verbosity_to_format( $verbosity );
    Perl::Critic::Violation::set_format( "# $format" );

    return $pc;
}

sub _check_perl_critic_violations {
    my ($git, $commit, $critic, $content, $filename) = @_;

    # Source code should only be passed to PPI::Document->new as a SCALAR reference
    my @violations = $critic->critique( \$content );
    $log->debugf( __PACKAGE__ . q{::}
        . '_check_perl_critic_violations():file=%s, violations=%s', $filename, \@violations);

    # Report errors
    foreach my $violation (@violations) {
        $git->fault("Perl::Critic error in file '$filename': " . $violation,
            {prefix => __PACKAGE__, commit => $commit});
    }

    # return number of errors
    return scalar @violations;
}

# TODO Make this dynamic, add more checkers.
my @PERL_CHECKERS = (
    {
        name => q{Perl::Critic},
        f => \&_check_perl_critic_violations,
        input => 'FILE_CONTENT',
    }
);

####################
# Main functions

sub check_new_or_modified_files {
    my ($git, $commit, @files) = @_;
    $log->debugf( __PACKAGE__ . q{::} . 'check_new_or_modified_files(%s, %s, %s)', 'git', $commit, \@files);
    my $errors = 0;

    my $critic = _set_critic($git);

    my @name_patterns;
    foreach my $check ($git->get_config($CFG => 'name')) {
        my ($pattern, $command) = split q{ }, $check, 2;
        # TODO Refactor regex.
        ## no critic (RegularExpressions::RequireDotMatchAnything)
        ## no critic (RegularExpressions::RequireExtendedFormatting)
        ## no critic (RegularExpressions::RequireLineBoundaryMatching)
        if ($pattern =~ m/^qr(.)(.*)\g{1}/) {
            $pattern = qr/$2/;
        } else {
            $pattern = glob_to_regex($pattern);
        }
        push @name_patterns, $pattern;
    }
    foreach my $file ($git->run(qw/ls-files -s/, @files)) {
        my ($mode, $sha, $n, $filename) = split q{ }, $file;
        $log->tracef( __PACKAGE__ . q{::}
            . 'check_new_or_modified_files():(mode, sha, n, name)=(%s, %s, %s, %s)',
            ($mode, $sha, $n, $filename)
        );
        my $basename = path($filename)->basename;
        $log->debugf( __PACKAGE__ . q{::} . 'check_new_or_modified_files():basename=%s', $basename);
        # The regexes generated from globs might not be /msx compatible.
        ## no critic (RegularExpressions::RequireDotMatchAnything)
        ## no critic (RegularExpressions::RequireExtendedFormatting)
        ## no critic (RegularExpressions::RequireLineBoundaryMatching)
        next if( ! any { $basename =~ m/$_/ } @name_patterns);
        my $content = $git->run(qw/cat-file -p/, $sha);
        $log->tracef( __PACKAGE__ . q{::} . 'check_new_or_modified_files():content=%s', $content);

        foreach my $checker ( @PERL_CHECKERS ) {
            my @violations;
            if( $checker->{'input'} eq q{FILE_CONTENT} ) {
                # Source code should only be passed to PPI::Document->new as a SCALAR reference
                @violations = $critic->critique( \$content );
            } else {
                # Save file to /tmp dir. Not implemented
            }
            $log->debugf( __PACKAGE__ . q{::}
                . 'check_new_or_modified_files():file=%s, violations=%s', $filename, \@violations);

            # Report errors
            foreach my $violation (@violations) {
                $git->fault(q{[} . $checker->{'name'} . "] error in file '$filename':\n" . $violation,
                    {prefix => 'CheckPerl', commit => $commit});
            }
        }
    }
    return $errors;
}

sub check_commit {
    my ($git) = @_;
    return check_new_or_modified_files($git, ':0', $git->filter_files_in_index('AM'));
}
sub check_ref {
    my ($git, $ref) = @_;
    my ($old_commit, $new_commit) = $git->get_affected_ref_range($ref);
    return check_new_or_modified_files(
        $git,
        $new_commit,
        $git->filter_files_in_range('AM', $old_commit, $new_commit),
    );
}
sub check_patchset {
    my ($git, $branch, $commit) = @_;
    return check_everything($git, $branch, $commit->commit, $commit->extra);
}

# Install hooks
my $options = {config => \&_setup_config};

GITHOOKS_CHECK_PRE_COMMIT    (\&check_commit,   $options);
GITHOOKS_CHECK_AFFECTED_REFS (\&check_ref,      $options);
GITHOOKS_CHECK_PATCHSET      (\&check_patchset, $options);

1;
